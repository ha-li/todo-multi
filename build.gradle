import dsl.XsltReport


apply plugin: 'groovy'

// the root project does not have any code, so we do not need
// to apply the java plugin
// apply plugin: 'java'

// import the ant file
ant.importBuild 'build.xml'

// each subproject gets their own project configuration
// which will declare
// 1. any properties,
// 2. plugins,
// 3. dependencies and
// 4. repositories

description = "A Multi Project Gradle Application"

task wrapper (type: Wrapper) {
   // specify the gradle version to use with wrapper
   gradleVersion = '3.2'
}

//apply all the common behavior to all projects here
allprojects {
   apply plugin: 'idea'

   group = 'com.gecko'
   version = '0.1'
}

// apply behavior common to sub projects here
subprojects {
   apply plugin: 'java'
   apply plugin: 'distribution'

   // reference the jacoco plugin defined here
   apply from: "$rootDir/gradle/jacoco.gradle"

   ext.configDir = new File (rootDir, 'config')
   // apply from: "$rootDir/gradle/checkstyle.gradle"
}

//test.dependsOn (subprojects.test)

task explodeWar (type: Copy) {
   into "$buildDir/explodedDist"
   subprojects {
      from tasks.withType(War)
   }
}

// this is a task from the ant script
// i'm extending it by adding doFirst and doLast
// executing this will execute doFirst, then the ant
// task, then doLast.
ninjaGreet{
   doFirst {
      println "Fellow Ninja!"
   }

   doLast {
      println 'Hello there!'
   }
}

repositories {
   mavenCentral ()
   maven {
      url uri ('../gradle-plugins')
   }
}

dependencies {
   compile 'org.codehaus.groovy:groovy-all:2.4.7'
   //classpath group: 'com.gecko', name: 'gradle-plugins', version: '0.1'
}

/**
 * Some cool stuff to illustrate how gradle works.
 *  1. define a class called DependencySpec that has a method testCompile
 *  2. testCompile takes in a String, and outputs the string "adding ... library..."
 *
 *  3. define a method called 'dependencies2' that takes a closure
 *     (we'll explain what the method does in a sec)
 *  4. we make a method call to dependencies2, and in that method we call testCompile ('junit...')
 *
 *There should be some weird stuff here that confuses you...
 *  a. when calling dependencies2 we pass in a closure that makes a method call testCompile...
 *     but the method testCompile is not defined in the closure,
 *     it is defined in the class DependencySpec, that's what the method dependencies2
 *     is doing. dependencies2 is passed in a Closure object, and it
 *     delegates the closure to the DependencySpec object, so anything that
 *     happens inside the closure is invoked/delegated to the DependencySpec obj,
 *     which does have the testCompile method defined
 */
class DependencySpec {
   def testCompile (String libraryIdentifier) {
      println "adding the $libraryIdentifier library..."
   }

   def doNothing () {
      println "doing nothing in Dependency Spec"
   }
}

def dependencies2 (Closure configurationClosure) {
   def dependencySpec = new DependencySpec ()
   configurationClosure.delegate = dependencySpec
   configurationClosure.resolveStrategy = Closure.DELEGATE_FIRST
   configurationClosure ()
}

def doNothing (Closure configuration) {
   println "doing nothing in space"
}

dependencies2 {
   testCompile "junit:junit:4.11"
   doNothing ()
}

doNothing ({})
